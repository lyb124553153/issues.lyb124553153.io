#单例

单例模式的核心思想是让指定的类只存在唯一一个实例。这意味着当你第二次使用相同的类去创建对象的时候，你得到的应该和第一次创建的是同一个对象。
```js
var obj1 = {name:'OBJ'}
var obj2 = {name:'OBJ'}
obj1 === obj2; // false
obj1 == obj2; // false


```
在JavaScript中，对象永远不会相等，除非它们是同一个对象，所以即使你创建一个看起来完全一样的对象，它也不会和前面的对象相等：

>你可以说当你每次使用对象字面量创建一个对象的时候就是在创建一个单例，并没有特别的语法迁涉进来。


##使用NEW

JavaScript没有类，所以一字一句地说单例的定义并没有什么意义。
但是JavaScript有使用new、通过构造函数来创建对象的语法，有时候你可能需要这种语法下的一个单例实现。
这也就是说当你使用new、通过同一个构造函数来创建多个对象的时候，你应该只是得到同一个对象的不同引用。


当对象实例被创建时，你需要在构造函数中缓存它，以便在第二次调用的时候返回。有几种选择可以达到这种效果：

    你可以使用一个全局变量来存储实例。不推荐使用这种方法，因为通常我们认为使用全局变量是不好的。而且，任何人都可以改写全局变量的值，甚至可能是无意中改写。所以我们不再讨论这种方案。
    你也可以将对象实例缓存在构造函数的属性中。在JavaScript中，函数也是对象，所以它们也可以有属性。你可以写一些类似Universe.instance的属性来缓存对象。这是一种漂亮干净的解决方案，不足之处是instance属性仍然是可以被公开访问的，别人写的代码可能修改它，这样就会失去这个实例。
    你可以将实例包裹在闭包中。这可以保持实例是私有的，不会在构造函数之外被修改，代价是一个额外的闭包。

###将实例放到静态属性中

下面是一个将唯一的实例放入Universe构造函数的一个静态属性中的例子：


```js
function SingleObj(){
    if (typeof  SingleObj.instance === "Object"){
        return SingleObj.instance
    }
    
    this.name = "Single"
    this.live = "now"    
    
    SingleObj.instance = this
}

var obj0 = new SingleObj();
var obj1 = new SingleObj();
obj0 === obj1;

```
### 将实例放在闭包中

```js
function SingleObj() {
  var instance = this ;
    this.name = "Single"
     this.live = "now" 
   SingleObj = function () {
          return instance;
      };
  
}
var sin1 = new SingleObj();
var sin2 = new SingleObj();
sin1 === sin2;

```
这种模式的缺点是被重写的函数（SingleObj()）将丢失那些在初始定义和重新定义之间添加的属性。在这个例子中，任何添加到SingleObj()的原型上的属性将不会被链接到使用原来的实现创建的实例上。


```js
SingleObj.prototype.hasProto = true

var sin0 = new SingleObj();

SingleObj.prototype.hasSomething = true ;


var sin1 = new Universe();

sin0.hasProto;//true
sin1.hasProto;//true
sin0.hasSomething;// undefined
sin1.hasSomething;// undefined
sin0.constructor.name //


sin0.constructor === SingleObj; // false
```
sin0.constructor 仍然指向原来的构造函数，而不是被重新定义的函数。

通过重写SingleObj是prototype和constructor的指向像我们期望的
```js
function SingleObj() {
  var instance = this ;
   SingleObj = function () {
            return instance;
        };
        SingleObj.prototype = this ;        
        instance = new SingleObj();
        instance.constructor = SingleObj
        
        
    this.name = "Single"
     this.live = "now" 
    
    
    return instance 
  
}

```
输出一切正常
```js



SingleObj.prototype.hasProto = true

var sin0 = new SingleObj();

SingleObj.prototype.hasSomething = true ;


var sin1 = new Universe();

sin0.hasProto;//true
sin1.hasProto;//true
sin0.hasSomething;// true
sin1.hasSomething;// true
sin0.constructor.name // SingleObj
sin0.constructor === SingleObj; // false

```


可选结局方案
将构造函数和实例包在一个立即执行的函数中。当构造函数第一次被调用的时候，它返回一个对象并且将私有的instance指向它。
在后续调用时，构造函数只是简单地返回这个私有变量。在这种新的实现下，前面所有的测试代码也会和期望的一样：
```js
var SingleObj
(function(){
    var instance ;
    SingleObj = function SingleObj(){
        if (instance ){
            return instance
        }
        
        instance = this ;
        this.name ="Single"
        this.runtime = "now"
        //....        
    }
}())



```


